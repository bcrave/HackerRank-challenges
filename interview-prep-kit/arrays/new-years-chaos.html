<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Number of Bribes</title>
	</head>
	<body>
		<h1>HackerRank Challenge:</h1>
		<h2>New Year's Chaos</h2>
		<script>
			// source - https://www.hackerrank.com/challenges/new-year-chaos/problem
			// My attempted solution

			const minimumBribes = (q) => {
				let counter = 0;
				for (let i = 0; i < q.length; i++) {
					let difference = q[i] - (i + 1);

					if (difference === 0) {
						continue;
					} else if (difference < 0 && i > 0) {
						let newDiff = q[i - 1] - i;

						if (newDiff < 0) {
							counter++;
						} else {
							continue;
						}
					} else if (difference > 2) {
						counter = "Too chaotic";
						break;
					} else {
						counter += difference;
					}
				}
				console.log(counter);
			};

			minimumBribes([2, 1, 5, 3, 4]); // 3
			minimumBribes([2, 5, 1, 3, 4]); // Too chaotic
			minimumBribes([5, 1, 2, 3, 7, 8, 6, 4]); // Too chaotic
			minimumBribes([1, 2, 5, 3, 7, 8, 6, 4]); // 7

			// Solution from Shaddyjr: https://gist.github.com/Shaddyjr/1b82bc01460676b58a5006498237758d
			// function minimumBribes(q) {
			// 	const TOO_CHAOTIC = "Too chaotic";
			// 	let total = 0;

			// 	for (let current_pos = 0; current_pos < q.length; current_pos++) {
			// 		// O(n)
			// 		// getting original position using 0 indexing (starts at 0)
			// 		const original_pos = q[current_pos] - 1;

			// 		// diff = how far person has moved
			// 		const diff = original_pos - current_pos;
			// 		// if person has moved more than 2 spots, then impossible
			// 		if (diff > 2) return console.log(TOO_CHAOTIC);

			// 		// the if statement is not required, but shows understanding
			// 		if (diff <= 0) {
			// 			// check each person starting from one person ahead of original pos
			// 			// up until current position
			// 			for (let i = Math.max(0, original_pos - 1); i < current_pos; i++) {
			// 				// O(logn)
			// 				const start_pos_of_forward_person = q[i] - 1;
			// 				// if a person in front of current person started BEHIND
			// 				// current person, then current person MUST have been bribed by them
			// 				if (start_pos_of_forward_person > original_pos) {
			// 					total++;
			// 				}
			// 			}
			// 		}
			// 	}

			// 	console.log(total); // Time Complexity = O(n) * O(logn) = O(nlogn)
			// }

			// minimumBribes([2, 1, 5, 3, 4]); // 3
			// // 			   0, 1, 2, 3, 4
			// minimumBribes([2, 5, 1, 3, 4]); // Too chaotic
			// minimumBribes([5, 1, 2, 3, 7, 8, 6, 4]); // Too chaotic
			// minimumBribes([1, 2, 5, 3, 7, 8, 6, 4]); // 7
		</script>
	</body>
</html>

<!-- 
    1. [1, 2, 3, 4, 5, 6, 7, 8] 
    2. [1, 2, 5, 3, 4, 6, 7, 8] - 2 moves
    3. [1, 2, 5, 3, 7, 4, 6, 8] - 4 moves
    4. [1, 2, 5, 3, 7, 8, 4, 6] - 6 moves
    5. [1, 2, 5, 3, 7, 8, 6, 4] - 7 moves
-->
